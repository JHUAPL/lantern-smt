---
description: |
    API documentation for modules: lantern.

lang: en

classoption: oneside
geometry: margin=1in
papersize: a4

linkcolor: blue
links-as-notes: true
...


    
# Module `lantern` {#lantern}

Lantern: safer than a torch

The Lantern package contains utility funcitons to support formal
verification of PyTorch modules by encoding the behavior of (certain)
neural networks as Z3 constraints.

The 'public' API includes:

- round_model(model, sbits)
- as_z3(model, sort, prefix)




    
## Functions


    
### Function `as_z3` {#lantern.as_z3}



    
> `def as_z3(model, sort=Real, prefix='')`


Calculate z3 constraints from a torch.nn.Sequential model.

Returns (constraints, z3_input, z3_output) where:

- constraints is a list of z3 constraints for the entire network
- z3_input is z3.RealVector representing the input to the network
- z3_output is a z3.RealVector representing output of the network

There are several caveats:

- The model must be a torch Sequential
- The first layer must be Linear
- Dropout layers are ignored
- Identity layers are ignored
- Supported layers are: Linear, ReLU, Hardtanh, Dropout, Identity
- An Exception is raised on any other type of layer

sort defaults to z3.RealSort(), but floating point sorts are
permitted; note that z3.FloatSingle() matches the default behavior
of PyTorch more accurately (but has different performance
characteristics compared to a real arithmetic theory

prefix is an optional string prefix for the generated z3 variables

    
### Function `const_vector` {#lantern.const_vector}



    
> `def const_vector(prefix, length, sort=Real)`


Returns a list of z3 constants of given sort.

e.g. const_vector("foo", 5, z3.FloatSingle())
Returns a list of 5 FP

    
### Function `encode_hardtanh` {#lantern.encode_hardtanh}



    
> `def encode_hardtanh(x, y, min_val=-1, max_val=1)`


Returns a list of z3 constraints corresponding to:

y == hardtanh(x, min_val=-1, max_val=1)

Where: x, y are lists of z3 variables

    
### Function `encode_linear` {#lantern.encode_linear}



    
> `def encode_linear(W, b, x, y)`


Returns a list of z3 constraints corresponding to:

y == W * x + b

Where: x, y are lists of z3 variables,
       W, b are pytorch tensors

    
### Function `encode_relu` {#lantern.encode_relu}



    
> `def encode_relu(x, y)`


Returns a list of z3 constraints corresponding to:

y == relu(x)

Where: x, y are lists of z3 variables

    
### Function `hacky_sum` {#lantern.hacky_sum}



    
> `def hacky_sum(coll)`


Because z3.Sum() doesn't work on FP sorts

    
### Function `round_model` {#lantern.round_model}



    
> `def round_model(model, sbits=52)`


Return a new model where every value in the original state dict has
had its fractional precision reduced to number of sbits. Exponent
part remains the same (11 bits) so the result can be returned as
a Python float.

Note that sbits=52 is a no-op. Single precision sbits=23; half=10

    
### Function `truncate_double` {#lantern.truncate_double}



    
> `def truncate_double(f, sbits=52)`


Truncate the significand/mantissa precision of f to number of sbits.

Note that f is expected to be a Python float (double precision).

sbits=52 is a no-op



-----
Generated by *pdoc* 0.8.1 (<https://pdoc3.github.io>).
